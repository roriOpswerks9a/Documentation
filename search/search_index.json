{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>This document represents our team\u2019s effort to design and implement a modern Continuous Integration (CI) and Continuous Deployment (CD) using industry-standard DevOps tools.</p> <p>Our goal is to create a solution that does more than just build and deploy code \u2014 it must follow best practices for automation, reliability, collaboration, and recovery.  </p> <p>The technologies chosen are TeamCity, Jenkins, Spinnaker, and Istio, which reflect the tools used in real-world production environments across many organizations.</p>"},{"location":"#purpose-of-this-document","title":"\ud83c\udfaf Purpose of this Document","text":"<ul> <li>To serve as a technical reference for panelists, advisers, and engineers reviewing our case study.  </li> <li>Provide clarity on how code changes move from integration to development all the way to production.  </li> <li>To act as a runbook and operations manual, showing how we plan to respond when failures happen.  </li> </ul>"},{"location":"#scope","title":"\ud83d\udccc Scope","text":"<p>This case study covers:</p> <ul> <li>Source code version control using GitHub with strict branching discipline.  </li> <li>Build automation using TeamCity for testing and Jenkins for Docker image creation.  </li> <li>Deployment automation using Spinnaker with canary deployment enabled by Istio.  </li> <li>Operational readiness through simulated incidents, troubleshooting, and recovery.  </li> </ul>"},{"location":"#outcome","title":"\ud83d\udcd6 Outcome","text":"<p>By following this documentation, you\u2019ll gain both a technical roadmap and an operational playbook for managing CI/CD.</p>"},{"location":"description/","title":"\ud83d\udcc4 Description","text":""},{"location":"description/#description-of-the-solution","title":"Description of the Solution","text":"<p>Our team has developed a CI/CD solution that integrates four key tools across two distinct environments:</p> <ul> <li>CI Environment (Google Cloud VM):   Hosts Jenkins and TeamCity for source integration, build automation, and testing.  </li> <li>CD Environment (Kubernetes Cluster):   Runs Spinnaker for deployment orchestration and Istio for service mesh traffic management.  </li> </ul> <p>This separation keeps production clean: builds and tests run outside the cluster, while deployments and traffic management stay inside Kubernetes.</p> <p>The web application is a Java-based project (chosen because of its natural compatibility with TeamCity). It is containerized with Docker, versioned through GitHub, and deployed into Kubernetes.</p>"},{"location":"description/#deployment-strategy-canary-release-model","title":"Deployment Strategy: Canary Release Model","text":"<p>The deployment strategy follows a canary release model:</p> <ul> <li>Spinnaker automates the rollout.  </li> <li>Istio handles traffic routing, initially directing a small percentage of user traffic (e.g., 10%) to the new canary release.  </li> <li>Prometheus collects real-time performance metrics (latency, error rates, pod health) and provides data for Automated Canary Analysis (ACA).  </li> </ul> <p>If the canary passes health checks \u2192 Spinnaker promotes the new version to all users.  </p> <p>If it fails \u2192 Spinnaker triggers an automatic rollback to the last stable version.  </p> <p>This combination ensures safer deployments with reduced risk, high observability, and faster recovery.</p>"},{"location":"description/#architecture-diagram","title":"Architecture Diagram","text":"<pre><code>flowchart TD\n    subgraph VM[Google Cloud VM - CI Environment]\n        A[TeamCity] --&gt;|Unit Tests + Build Validation| B[Jenkins]\n        B --&gt;|Builds Docker Image| C[DockerHub]\n    end\n\n    subgraph K8s[Kubernetes Cluster - CD Environment]\n        C --&gt; D[Spinnaker]\n        D --&gt; E[Canary Deployment]\n        D --&gt; F[Stable Deployment]\n        E --&gt; G[Istio Traffic Split]\n        F --&gt; G\n        G --&gt; H[Users]\n        G --&gt; I[Prometheus Metrics]\n        I --&gt; D\n    end</code></pre>"},{"location":"description/#cicd-workflow-diagram","title":"CI/CD Workflow Diagram","text":"<pre><code>flowchart TD\n    A[Developer Commit &amp; Pull Request] --&gt; B[TeamCity Build &amp; Unit Tests]\n    B --&gt;|Pass| C[Jenkins Builds Docker Image]\n    C --&gt; D[Push Image to DockerHub]\n    D --&gt; E[Spinnaker Triggers Deployment]\n    E --&gt; F[Canary Pods in Kubernetes]\n    F --&gt; G[\"Istio Splits Traffic&lt;br/&gt;&lt;i&gt;10% Canary, 90% Stable&lt;/i&gt;\"]\n    G --&gt; H[Prometheus Monitors Metrics]\n    H --&gt;|Healthy| I[Promote Canary to Stable - 100% Traffic]\n    H --&gt;|Unhealthy| J[Rollback to Previous Stable]</code></pre>"},{"location":"features/","title":"Features","text":""},{"location":"features/#web-app-deployment","title":"\ud83d\udce6 Web App Deployment","text":"<ul> <li>Python-based web app containerized with Docker.  </li> <li>Runs in Kubernetes with five replicas for reliability.  </li> <li>Canary deployment strategy \u2192 traffic gradually shifted using Istio.  </li> </ul>"},{"location":"features/#ci-with-teamcity","title":"\u2699\ufe0f CI with TeamCity","text":"<ul> <li>GitHub repo integrated with TeamCity.  </li> <li>Code compilation + unit testing automated on every Pull Request (PR).  </li> <li>Status checks ensure only passing builds can be merged.  </li> </ul>"},{"location":"features/#image-build-with-jenkins","title":"\ud83c\udfd7\ufe0f Image Build with Jenkins","text":"<ul> <li>Jenkins builds Docker images from source.  </li> <li>Dual tagging: <code>BUILD_NUMBER-hash</code> (versioned) + <code>latest</code>.  </li> <li>Pushes securely to DockerHub.  </li> </ul>"},{"location":"features/#cd-with-spinnaker","title":"\ud83d\ude80 CD with Spinnaker","text":"<ul> <li>Spinnaker watches DockerHub and/or Jenkins webhook.  </li> <li>Automatically deploys new images to canary, then stable.  </li> <li>Supports rollback if canary fails.  </li> </ul>"},{"location":"features/#automated-canary-releases-spinnaker-istio-prometheus","title":"Automated Canary Releases (Spinnaker + Istio + Prometheus)","text":"<ul> <li>Spinnaker \u2192 Orchestrates canary-first deployments.</li> <li>Istio \u2192 Splits traffic (e.g., 90% stable, 10% canary).</li> <li>Prometheus \u2192 Provides health metrics for Automated Canary Analysis (ACA).</li> <li>If canary succeeds \u2192 promoted to full rollout.</li> <li>If canary fails \u2192 automatic rollback to stable version.</li> </ul>"},{"location":"features/#git-workflow-branch-protection","title":"\ud83c\udf3f Git Workflow &amp; Branch Protection","text":"<ul> <li><code>main</code> \u2192 production branch.  </li> <li><code>dev</code> \u2192 development/testing branch.  </li> <li>Pull Request workflow enforced with reviews + approvals.  </li> </ul>"},{"location":"features/#resilience-recovery","title":"\ud83d\udee1\ufe0f Resilience &amp; Recovery","text":"<ul> <li>Runbooks prepared for CI/CD failures, merge conflicts, and rollout issues.  </li> <li>Ability to quickly rollback to last stable release.  </li> </ul>"},{"location":"recovery/","title":"Recovery","text":""},{"location":"runbook/","title":"Runbook","text":"<p>Sample ra ni testing area relax</p> Step 1<pre><code># Function to add two numbers\ndef add_two_numbers(num1, num2):\n    return num1 + num2\n\n# Example usage\nresult = add_two_numbers(5, 3)\nprint('The sum is:', result)\n</code></pre> Step 2<pre><code># Function to add two numbers\ndef add_two_numbers(num1, num2):\n    return num1 + num2\n\n# Example usage\nresult = add_two_numbers(5, 3)\nprint('The sum is:', result)\n</code></pre> Step 3<pre><code># Function to add two numbers\ndef add_two_numbers(num1, num2):\n    return num1 + num2\n\n# Example usage\nresult = add_two_numbers(5, 3)\nprint('The sum is:', result)\n</code></pre> Step 4<pre><code># Function to add two numbers\ndef add_two_numbers(num1, num2):\n    return num1 + num2\n\n# Example usage\nresult = add_two_numbers(5, 3)\nprint('The sum is:', result)\n</code></pre>"},{"location":"tools/","title":"Tools","text":""},{"location":"tools/#github","title":"GitHub","text":"<ul> <li>Manages version control with <code>main</code> (production) and <code>dev</code> (development) branches.  </li> <li>Pull Requests enforce collaboration, approval, and status checks.  </li> <li>Prevents direct commits to <code>main</code>.  </li> </ul>"},{"location":"tools/#teamcity","title":"TeamCity","text":"<ul> <li>Acts as our Continuous Integration system.  </li> <li>Builds the Java app, runs automated unit tests, and reports results.  </li> <li>Provides status checks that must pass before merging PRs.  </li> </ul>"},{"location":"tools/#jenkins","title":"Jenkins","text":"<ul> <li>Specializes in building container images.  </li> <li>Uses Jenkinsfile to automate Docker builds and push images to DockerHub.  </li> <li>Ensures every build has a versioned tag and a moving latest tag.</li> </ul>"},{"location":"tools/#dockerhub","title":"DockerHub","text":"<ul> <li>Central registry for all container images.  </li> <li>Acts as the trigger source for Spinnaker pipelines.  </li> </ul>"},{"location":"tools/#spinnaker-cd","title":"Spinnaker (CD)","text":"<ul> <li>Orchestrates continuous delivery.  </li> <li>Deploys canary first, then promotes to stable if successful.  </li> <li>Integrates with DockerHub to auto-trigger on new images.  </li> </ul>"},{"location":"tools/#prometheus","title":"Prometheus","text":"<ul> <li>Monitors application health during deployments.</li> <li>Tracks latency, error rates, and pod readiness.</li> <li>Provides feedback for rollback or promotion decisions.</li> </ul>"},{"location":"tools/#istio","title":"Istio","text":"<ul> <li>Service mesh that controls traffic routing.  </li> <li>Splits traffic between stable and canary deployments.  </li> <li>Provides observability into rollout performance.  </li> </ul>"},{"location":"tools/#kubernetes","title":"Kubernetes","text":"<ul> <li>Hosts the application workloads.  </li> <li>Ensures five healthy replicas are always running.  </li> <li>Provides scaling, self-healing, and deployment orchestration.</li> </ul>"},{"location":"tools/#cicd-workflow","title":"CI/CD Workflow","text":"<p>The figure below illustrates the end-to-end workflow of our CI/CD pipeline:</p>"},{"location":"tools/#step-by-step-cicd-pipeline-explanation","title":"Step-by-Step CI/CD Pipeline Explanation","text":""},{"location":"tools/#1-github-pull-request","title":"1. GitHub Pull Request","text":"<ul> <li>Developers open a Pull Request (PR) with new changes.</li> <li>Ensures collaboration, review, and branch protection.</li> </ul>"},{"location":"tools/#2-teamcity-tests","title":"2. TeamCity Tests","text":"<ul> <li>The PR triggers unit tests in TeamCity.</li> <li>Only passing PRs can move forward.</li> </ul>"},{"location":"tools/#3-changes-in-repo-merge","title":"3. Changes in Repo (Merge)","text":"<ul> <li>Once approved, PRs are merged into <code>main</code> or <code>dev</code>.</li> <li><code>main</code> \u2192 Production, <code>dev</code> \u2192 Development/testing.</li> </ul>"},{"location":"tools/#4-jenkins-build","title":"4. Jenkins Build","text":"<ul> <li>Merges trigger Jenkins to:<ul> <li>Build a Docker image.</li> <li>Tag the image with:<ul> <li>:buildNumber-hash (e.g., 42-a1b2c3d) \u2192 unique, traceable version.</li> <li>:latest \u2192 always points to the newest successful build.</li> </ul> </li> <li>Push both tags to Docker Hub.</li> </ul> </li> </ul>"},{"location":"tools/#5-spinnaker-deployment","title":"5. Spinnaker Deployment","text":"<ul> <li>Spinnaker detects the new image.</li> <li>Deploys it to Kubernetes with a canary rollout:<ul> <li>Canary pods \u2192 test stability.</li> <li>If successful \u2192 promote to all pods (stable).</li> </ul> </li> </ul>"},{"location":"tools/#6-prometheus-monitoring","title":"6. Prometheus Monitoring","text":"<ul> <li>Prometheus collects metrics (pod health, latency, error rates).</li> <li>Canary rollout decisions are supported by Prometheus data.</li> </ul>"},{"location":"tools/#jenkinsfile","title":"Jenkinsfile","text":"<p>Our Jenkins pipeline automates image building and pushing to Docker Hub. Below is the pipeline definition and its explanation.</p> <pre><code>pipeline {\nagent { label 'i9a-builder' }\noptions { timestamps() }\n</code></pre> <pre><code>environment {\nIMAGE = 'afk24cmd/miniapp'\nTAG = \"${env.BUILD_NUMBER}-${env.GIT_COMMIT.take(7)}\"\nSPINNAKER_WEBHOOK = 'https://spinnaker-api.example.com/webhooks/webhook/my-pipeline'\n}\n</code></pre> <pre><code>stages {\nstage('Checkout') {\nsteps { checkout scm }\n}\n}\n</code></pre> <pre><code>stage('Docker Login') {\nsteps {\nwithCredentials([usernamePassword(\ncredentialsId: 'dockerhub-creds',\nusernameVariable: 'DHU',\npasswordVariable: 'DHP'\n)]) {\nsh 'echo \"$DHP\" | docker login -u \"$DHU\" --password-stdin'\n}\n}\n}\n</code></pre> <pre><code>stage('Build Image') {\nsteps {\nsh 'docker build -t $IMAGE:$TAG -t $IMAGE:latest .'\n}\n}\n</code></pre> <pre><code>stage('Build Image') {\nsteps {\nsh 'docker build -t $IMAGE:$TAG -t $IMAGE:latest .'\n}\n}\n</code></pre> <pre><code>stage('Trigger Spinnaker') {\nsteps {\nsh 'curl -X POST -H \"Content-Type: application/json\" \\\\\n-d \"{\\\\\\\"artifacts\\\\\\\":[{\\\\\\\"type\\\\\\\":\\\\\\\"docker/image\\\\\\\",\\\\\\\"reference\\\\\\\":\\\\\\\"$IMAGE:$TAG\\\\\\\"}]}\" $SPINNAKER_WEBHOOK'\n}\n}\n}\n</code></pre> <pre><code>post {\nalways {\nsh 'docker logout || true'\n}\nsuccess {\necho \"\u2705 Pushed $IMAGE:$TAG and $IMAGE:latest and notified Spinnaker\"\n}\nfailure {\necho \"\u274c Build/push failed \u2014 check logs.\"\n}\n}\n</code></pre>"},{"location":"tools/#explaination-of-stages","title":"Explaination of Stages","text":"<ul> <li>Checkout \u2192 Pulls latest source code from GitHub.</li> <li>Docker Login \u2192 Uses Jenkins credentials for secure DockerHub authentication.</li> <li>Build Image \u2192 Builds Docker image with dual tagging (:buildNumber-hash + :latest).</li> <li>Push Image \u2192 Pushes both tags to DockerHub registry.</li> <li>Post Actions \u2192 Ensures logout from DockerHub and logs build result.</li> </ul>"},{"location":"workflow/","title":"Workflow","text":""}]}